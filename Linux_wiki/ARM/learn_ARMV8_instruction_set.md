ARM64寄存器   
寄存器:说明
X0 ~ X7:用于传递子程序参数和结果，使用时不需要保存，多余参数采用堆栈传递。
64位返回结果采用 X0 表示，128位返回结果采用 X1:X0 表示。
X8:用于保存子程序返回地址， 尽量不要使用。
X9 ~ X15:临时寄存器，使用时不需要保存。
X16 ~ X17：子程序内部调用寄存器，使用时不需要保存，尽量不要使用。
X18	平台寄存器，它的使用与平台相关，尽量不要使用。
X19 ~ X28：临时寄存器，使用时必须保存。
X29/FP：FP（ Frame Pointer ）栈底指针（64bit）
X30/LR：LR（Link Register）程序链接寄存器（64bit），保存子程序结束后需要执行的下一条指令
X31/SP：SP（Stack Pointer）栈指针（64bit），使用 SP/WSP来进行对SP寄存器的访问。
PC:程序计数器（64bit），俗称PC指针，总是指向即将要执行的下一条指令。
在arm64中，软件是不能改写PC寄存器的。
CPSR:状态寄存器，在arm64位上用pstate代替
注   
1、ARM64寄存器有两种使用模式，64位时称为 X0 ~ X30，32位时称为 W0 ~ W30。
2、ARM64的LR、FP放在栈顶，而ARM放在栈底；
ARM64中当前FP和SP相同，都是栈顶指针，与x86的BP和SP不同，x86的BP和SP之间是整个函数栈帧；
函数返回时，ARM64先将栈中的LR值放入当前LR，再ret；而ARM直接将栈中的LR值放入PC；
使用gcc编译选项-fomit-frame-pointer，可以使ARM64不使用FP寄存器，这时栈帧稍有变化，栈不在保存FP，局部变量寻址过程也不使用该寄存器。


ARM汇编：汇编中proc、endp、ret、near、far指令用法

子程序名 PROC NEAR ( 或 FAR )
……
ret
子程序名 ENDP
（1）NEAR属性(段内近调用): 调用程序和子程序在同一代码段中,只能被相同代码段的其他程序调用;
FAR属性(段间远调用): 调用程序和子程序不在同一代码段中,可以被相同或不同代码段的程序调用.

（2）proc是定义子程序的伪指令，位置在子程序的开始处，它和endp分别表示子程序定义的开始和结束两者必须成对出现。

（3）ret指令的内部操作是：栈顶字单元出栈，其值赋给IP寄存器。即实现了一个程序的转移，将栈顶字单元保存的偏移地址作为下一条指令的偏移地址。

来自 <https://blog.csdn.net/weibo1230123/article/details/84235296>

[ARMv8体系结构基础05：比较和跳转指令]<https://blog.csdn.net/chenchengwudi/article/details/123917082>



